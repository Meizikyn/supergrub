# Super Grub Disk - supergrub-mkcommon
# Copyright (C) 2009,2010,2011,2012,2013,2014,2015  Adrian Gibanel Lopez.
#
# Super Grub Disk is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Super Grub Disk is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Super Grub Disk.  If not, see <http://www.gnu.org/licenses/>.

function init_overlay_dir () {

  mkdir -p "$overlay/boot/grub/"
  cp -r menus/* "$overlay/boot/grub/"
}

function copy_boot_isos_directory () {

  if [ -d ${BOOT_ISOS_DIRECTORY} ] ; then
    cp -r ${BOOT_ISOS_DIRECTORY} "$overlay/boot/"
  fi

}

function copy_copyright () {

  cp AUTHORS COPYING "$overlay/boot/grub/sgd/"

}

function generate_and_copy_mo_files () {

  # Generate mo files and add them to overlay
  for pofile in po/*.po; do
    basename=${pofile##*/}
    lang_code="${basename%.po}"
    info_cfg="menus/sgd/sgd_locale/${lang_code}_info.cfg"
    msgfmt "$pofile" --output-file="$overlay/boot/grub/sgd/sgd_locale/${lang_code}.mo"
    if ! [[ -f "$info_cfg" ]]; then
      echo "Thank you for providing a new translation for Super GRUB2 Disk!"
      echo "Before this translation can be used in Super GRUB2 Disk we need to know what"
      echo "to call it in our language selection menu."
      echo "We need to know the name of the language you've translated, in that language."
      echo "For example, for Spanish you would enter \"EspaÃ±ol\" (without the quotes)."
      echo -n "Please enter the name of the language for $pofile: "
      read language_name
      cp info_cfg_header.cfg "$info_cfg"
      echo "lang_code='${lang_code}'" >> "$info_cfg"

      # This will fail if $language_name contains a single quote character.
      # TODO: Fix aforementioned problem by escaping quotes in $language_name.
      echo "language_name='${language_name}'" >> "$info_cfg"

      echo "A file, ${info_cfg}, was created with this information."
      echo "Thanks again for contributing a new translation!"
      echo; echo
    fi
  done

}

function check_unifont () {

  # Find unifont font file to create grub font. This is needed for gfxterm in grub, which
  # in turn is needed for displaying non-ASCII characters for non-English translations.
  # This unifont finding code was copied from grub's configure.ac.
  for ext in pcf pcf.gz bdf bdf.gz ttf ttf.gz; do
    for dir in . /usr/src /usr/share/fonts/X11/misc /usr/share/fonts/unifont; do
      if test -f "$dir/unifont.$ext"; then
	font_source="$dir/unifont.$ext"
	break 2
      fi
    done
  done

  if [[ -n "$font_source" ]]; then
    "$GRUB_MKFONT_BINARY" "$font_source" --output="$overlay/boot/grub/unifont.pf2"
  else
    echo "Error: Unifont not found. Unifont is needed for Super GRUB2 Disk" >&2
    echo "to properly display non-ASCII characters. Aborting without creating an iso." >&2
    exit 1
  fi

}

function generate_filename_hashes ()  {
  local ISO_FILENAME="$1"
  local TMP_PRE_CHECKSUMS_DIR="$(pwd)"
  local SHORT_ISO_FILENAME="$(basename ${ISO_FILENAME})"
  local ISO_FILENAME_DIR="$(dirname ${ISO_FILENAME})"

  cd "${ISO_FILENAME_DIR}"

  md5sum ${SHORT_ISO_FILENAME} > ${SHORT_ISO_FILENAME}.md5
  sha1sum ${SHORT_ISO_FILENAME} > ${SHORT_ISO_FILENAME}.sha1
  sha256sum ${SHORT_ISO_FILENAME} > ${SHORT_ISO_FILENAME}.sha256

  cd "${TMP_PRE_CHECKSUMS_DIR}"

}

function generate_SG2D_UUID_FILE () {

  LIVEID_DIR_PREFIX="LIVEID"

  SG2D_UUID_SEED="\
${ISO_FILENAME}\
-\
${GRUB_MKRESCUE_BINARY}\
-\
${GRUB_MKFONT_BINARY}\
-\
${EFI_PLATFORMS}\
"

  SG2D_UUID=$(echo -n "${SG2D_UUID_SEED}" | md5sum | tr 'a-z' 'A-Z')

  SG2D_UUID_DIR1="$(echo ${SG2D_UUID} | cut -c1-8)"
  SG2D_UUID_DIR2="$(echo ${SG2D_UUID} | cut -c9-16)"
  SG2D_UUID_DIR3="$(echo ${SG2D_UUID} | cut -c17-24)"
  SG2D_UUID_FILE4="$(echo ${SG2D_UUID} | cut -c25-32)"

  SG2D_UUID_DIR="${LIVEID_DIR_PREFIX}/${SG2D_UUID_DIR1}"'/'"${SG2D_UUID_DIR2}"'/'"${SG2D_UUID_DIR3}"
  SGD2_UUID_FILE="${SG2D_UUID_DIR}"'/'"${SG2D_UUID_FILE4}"

  mkdir -p "$overlay/${SG2D_UUID_DIR}/"
  touch "$overlay/${SGD2_UUID_FILE}"

}

function copy_secureboot_external_efis () {

  # Return if this is not an actual efi platform
  if [ "${EFI_PLATFORMS}" == "none" ] ; then
    return 0;
  fi

  PRE_LOOP_DIR="$(pwd)"
  for nefiplatform in ${EFI_PLATFORMS} ; do
    cd ${SG2D_SECUREBOOT_BINARIES_DIR}/vendors
    for nvendor in * ; do
      if [ -e "${nvendor}/shim${nefiplatform}.efi" ] ; then
        if [ ! -d "${overlay}/EFI/${nvendor}" ] ; then
          mkdir -p "${overlay}/EFI/${nvendor}"
        fi
        cp "${nvendor}/shim${nefiplatform}.efi" "${overlay}/EFI/${nvendor}"
        cp "${nvendor}/grub${nefiplatform}.efi" "${overlay}/EFI/${nvendor}"
      fi
    done
  done

  cd "${PRE_LOOP_DIR}"


}

Lodetach ()
{
  DEVICE="${1}"
  ATTEMPT="${2:-1}"

  if [ "${ATTEMPT}" -gt 3 ]
  then
    echo "Failed to detach loop device (${DEVICE})."
    exit 1
  fi

  # Changes to block devices result in uevents which trigger rules which in
  # turn access the loop device (ex. udisks-part-id, blkid) which can cause
  # a race condition. We call 'udevadm settle' to help avoid this.
  if [ -x "$(which udevadm 2>/dev/null)" ]
  then
    udevadm settle
  fi

  # Loop back devices aren't the most reliable when it comes to writes.
  # We sleep and sync for good measure - better than build failure.
  sync
  sleep 1

  /sbin/losetup -d "${DEVICE}" || Lodetach "${DEVICE}" "$(expr ${ATTEMPT} + 1)"
}

Losetup ()
{
  DEVICE="${1}"
  FILE="${2}"
  PARTITION="${3:-1}"

  /sbin/losetup --read-only --partscan "${DEVICE}" "${FILE}"
  FDISK_OUT="$(/sbin/fdisk -l -u ${DEVICE} 2>&1)"
  Lodetach "${DEVICE}"

  LOOPDEVICE="$(echo ${DEVICE}p${PARTITION})"

  if [ "${PARTITION}" = "0" ]
  then
    echo "Mounting %s with offset 0 (${DEVICE})"

    /sbin/losetup --partscan "${DEVICE}" "${FILE}"
  else
    SECTORS="$(echo "$FDISK_OUT" | sed -ne "s|^$LOOPDEVICE[ *]*\([0-9]*\).*|\1|p")"
    OFFSET="$(expr ${SECTORS} '*' 512)"

    echo "Mounting %s with offset %s (${DEVICE}) (${OFFSET})"

    /sbin/losetup --partscan -o "${OFFSET}" "${DEVICE}" "${FILE}"
  fi
}

function generate_usb_image () {

  # Many code was adapted from binary_hdd and losetup.sh from live-build package

  # Step 1: Prepare the disk
  DU_DIM="$(du -ms ${overlay} | cut -f1)"
  REAL_DIM="$(expr ${DU_DIM} + ${DU_DIM} \* 3 / 100 + 1)"
  dd if=/dev/zero of=${ISO_FILENAME} bs=1024k count=0 seek=${REAL_DIM}
  echo "!!! The following error/warning messages can be ignored !!!"
  /sbin/parted -s ${ISO_FILENAME} mklabel msdos
  /sbin/parted -a optimal -s ${ISO_FILENAME} mkpart primary\
      fat32 0% 100%
  /sbin/parted -s ${ISO_FILENAME} set 1 boot on
  /sbin/parted -s ${ISO_FILENAME} set 1 lba off

  # Step 2: Prepare the filesystem
  FREELO="$(/sbin/losetup -f)"
  Losetup $FREELO ${ISO_FILENAME} 1
  mkfs.vfat -F 32 -n "SG2DSB" ${FREELO}

  # Step 3: Copy data
  SG2D_USB_TMP_MOUNT=$(mktemp -d)
  mount ${FREELO} ${SG2D_USB_TMP_MOUNT}
  cp -T -r ${overlay}/ ${SG2D_USB_TMP_MOUNT}

  # Step 4: Umount filesystem and detach device
  umount ${SG2D_USB_TMP_MOUNT}
  rmdir ${SG2D_USB_TMP_MOUNT}
  Lodetach ${FREELO}

}
